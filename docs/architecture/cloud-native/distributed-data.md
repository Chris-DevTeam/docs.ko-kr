---
title: 분선 데이터
description: 모놀리식 및 클라우드 네이티브 응용 프로그램의 데이터 저장소를 대조 합니다.
author: robvet
ms.date: 01/19/2021
ms.openlocfilehash: c83ac5dc973ff4c7a4626746472a74cfc6bf54bb
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505871"
---
# <a name="distributed-data"></a>분선 데이터

이 책 전반에서 살펴본 것 처럼 클라우드 기본 접근 방식은 응용 프로그램을 디자인, 배포 및 관리 하는 방식을 변경 합니다. 또한 데이터를 관리 하 고 저장 하는 방식을 변경 합니다.

그림 5-1에서는 차이점을 대조 합니다.

![클라우드 네이티브 응용 프로그램의 데이터 저장소](./media/distributed-data.png)

**그림 5-1**. 클라우드 네이티브 응용 프로그램의 데이터 관리

숙련 된 개발자는 그림 5-1의 왼쪽에 있는 아키텍처를 쉽게 인식할 수 있습니다. 이 *모놀리식 응용 프로그램* 에서 비즈니스 서비스 구성 요소는 단일 관계형 데이터베이스의 데이터를 공유 하는 공유 서비스 계층에서 함께 배치.

여러 가지 측면에서 단일 데이터베이스는 데이터 관리를 간단 하 게 유지 합니다. 여러 테이블에서 데이터를 쿼리 하는 것은 간단 합니다. 데이터 업데이트를 함께 변경 하거나 모두 롤백합니다. [ACID 트랜잭션은](/windows/desktop/cossdk/acid-properties) 강력 하 고 즉각적인 일관성을 보장 합니다.

클라우드 네이티브를 설계할 때 다른 접근 방법을 사용 합니다. 그림 5-1의 오른쪽에서 비즈니스 기능이 소규모의 독립적인 마이크로 서비스에 분리 하는 방식을 확인 합니다. 각 마이크로 서비스는 특정 비즈니스 기능과 자체 데이터를 캡슐화 합니다. 모놀리식 데이터베이스는 각각 마이크로 서비스를 사용 하 여 여러 개의 작은 데이터베이스를 포함 하는 분산 데이터 모델로 분해. 연기를 지우면 *마이크로 서비스 당 데이터베이스* 를 표시 하는 디자인이 제공 됩니다.

## <a name="database-per-microservice-why"></a>마이크로 서비스 데이터베이스의 이유는 무엇 인가요?

마이크로 서비스 당이 데이터베이스는 특히 신속 하 게 진화 하 고 대규모 확장을 지 원하는 시스템에 많은 이점을 제공 합니다. 이 모델을 사용 하 여 ...

- 도메인 데이터는 서비스 내에 캡슐화 됩니다.
- 다른 서비스에 직접 영향을 주지 않고 데이터 스키마를 개선할 수 있습니다.
- 각 데이터 저장소는 독립적으로 확장할 수 있습니다.
- 한 서비스의 데이터 저장소 오류는 다른 서비스에 직접적인 영향을 주지 않습니다.

또한 데이터를 분리 하면 각 마이크로 서비스가 작업, 저장소 요구 사항 및 읽기/쓰기 패턴에 가장 적합 한 데이터 저장소 형식을 구현할 수 있습니다. 관계형, 문서, 키 값 및 그래프 기반 데이터 저장소를 선택할 수 있습니다.

그림 5-2은 클라우드 네이티브 시스템에서 polyglot 지 속성의 원칙을 보여 줍니다.

![Polyglot 데이터 지 속성](./media/polyglot-data-persistence.png)

**그림 5-2**. Polyglot 데이터 지 속성

위의 그림에서 각 마이크로 서비스는 서로 다른 유형의 데이터 저장소를 지 원하는 방법을 설명 합니다.

- 제품 카탈로그 마이크로 서비스는 관계형 데이터베이스를 사용 하 여 기본 데이터의 풍부한 관계형 구조를 수용 합니다.
- 쇼핑 카트 마이크로 서비스는 간단한 키-값 데이터 저장소를 지 원하는 분산 캐시를 사용 합니다.
- 정렬 마이크로 서비스는 읽기 작업의 대량 사용을 수용 하기 위해 매우 비 정규화 된 키/값 저장소와 함께 쓰기 작업용 NoSql 문서 데이터베이스를 모두 사용 합니다.
  
관계형 데이터베이스는 복잡 한 데이터를 포함 하는 마이크로 서비스에 대 한 관련성을 유지 하지만 NoSQL 데이터베이스는 상당한 인기를 얻었습니다. 광범위 하 고 고가용성을 제공 합니다. 이러한 특성을 사용 하면 개발자는 형식화 된 데이터 클래스의 아키텍처에서 벗어나 서 비용이 많이 들고 시간이 오래 걸릴 수 있습니다. 이 챕터의 뒷부분에 NoSQL 데이터베이스가 포함 되어 있습니다.

 데이터를 별도의 마이크로 서비스에 캡슐화 하는 동안 민첩성, 성능 및 확장성을 높일 수 있습니다. 또한 많은 과제가 발생 합니다. 다음 섹션에서는 이러한 과제를 해결 하는 데 도움이 되는 패턴 및 방법에 대해 설명 합니다.  

## <a name="cross-service-queries"></a>서비스 간 쿼리

마이크로 서비스는 독립적 이며 재고, 배송 또는 주문과 같은 특정 기능에 중점을 두는 반면, 다른 마이크로 서비스와 통합 해야 하는 경우가 많습니다. 통합에는 데이터에 대 한 다른 마이크로 서비스 *쿼리* 를 포함 하는 경우가 많습니다. 그림 5-3은 시나리오를 보여 줍니다.

![마이크로 서비스 간 쿼리](./media/cross-service-query.png)

**그림 5-3**. 마이크로 서비스 간 쿼리

앞의 그림에는 사용자의 시장 바구니에 항목을 추가 하는 시장 바구니 마이크로 서비스이 표시 됩니다. 이 마이크로 서비스에 대 한 데이터 저장소는 바구니와 품목 데이터를 포함 하지만 제품 또는 가격 데이터는 유지 하지 않습니다. 대신 이러한 데이터 항목은 카탈로그 및 가격 마이크로 서비스에서 소유 합니다. 이 측면에서는 문제가 발생 합니다. 시장 바구니 마이크로 서비스 데이터베이스에 제품 및 가격 책정 데이터가 없는 경우 사용자의 시장 바구니에 제품을 추가 하는 방법

4 장에서 설명 하는 한 가지 옵션은 쇼핑 바구니에서 카탈로그 및 가격 책정 마이크로 서비스에 대 한 [직접 HTTP 호출](service-to-service-communication.md#queries) 입니다. 그러나 4 장에서는 동기 HTTP 호출을 통해 *두* 마이크로 서비스를 함께 제공 하 여 자율성을 줄이고 아키텍처 혜택을 축소 한다고 설명 했습니다.

각 서비스에 대해 별도의 인바운드 및 아웃 바운드 큐를 사용 하 여 요청-회신 패턴을 구현할 수도 있습니다. 그러나이 패턴은 복잡 하 고 요청 및 응답 메시지의 상관 관계를 파악 해야 합니다.
백엔드 마이크로 서비스 호출을 분리 하는 동안 호출 하는 서비스는 호출이 완료 될 때까지 동기적으로 대기 해야 합니다. 네트워크 정체, 일시적인 오류 또는 오버 로드 된 마이크로 서비스로 인해 장기 실행 및 실패 한 작업이 발생할 수 있습니다.

대신, 교차 서비스 종속성을 제거 하는 데 널리 승인 된 패턴은 그림 5-4에 표시 된 [구체화 된 뷰 패턴](/azure/architecture/patterns/materialized-view)입니다.

![구체화 된 뷰 패턴](./media/materialized-view-pattern.png)

**그림 5-4**. 구체화 된 뷰 패턴

이 패턴을 사용 하 여 쇼핑 바구니 서비스에서 로컬 데이터 테이블 ( *읽기 모델* 이라고 함)을 저장 합니다. 이 테이블에는 제품 및 가격 마이크로 서비스에서 필요한 정규화 되지 않은 데이터 사본이 포함 되어 있습니다. 시장 바구니 마이크로 서비스 데이터를 직접 복사 하면 비용이 많이 드는 서비스 간 호출이 필요 하지 않습니다. 서비스의 로컬 데이터를 사용 하 여 서비스의 응답 시간과 안정성을 향상 시킵니다. 또한 고유한 데이터 복사본을 사용 하면 시장 바구니 서비스의 복원 력이 향상 됩니다. 카탈로그 서비스를 사용할 수 없게 되 면 장바구니 서비스에 직접 영향을 주지 않습니다. 쇼핑 바구니는 자신의 저장소에서 데이터를 계속 사용할 수 있습니다.

이 방법을 사용 하는 경우 시스템에 중복 된 데이터가 있습니다. 그러나 클라우드 네이티브 시스템에서 데이터를 *전략적* 으로 복제 하는 것은 설정 된 습관 이며, 안전 하지 않은 방법이 나 잘못 된 방법으로 간주 되지 않습니다. 한 *서비스 에서만* 데이터 집합을 소유 하 고 해당 서비스에 대 한 권한을 가질 수 있다는 점에 유의 하세요. 레코드의 시스템이 업데이트 될 때 읽기 모델을 동기화 해야 합니다. 일반적으로 동기화는 그림 5.4에 표시 된 것 처럼 [게시/구독 패턴](service-to-service-communication.md#events)을 사용 하 여 비동기 메시지를 통해 구현 됩니다.

## <a name="distributed-transactions"></a>분산 트랜잭션

마이크로 서비스를 통해 데이터를 쿼리 하는 것이 어렵기 때문에 여러 마이크로 서비스에서 트랜잭션을 구현 하는 것은 훨씬 더 복잡 합니다. 서로 다른 마이크로 서비스의 독립적인 데이터 원본에서 데이터 일관성을 유지 관리 하는 내재 된 과제는 understated 수 없습니다. 클라우드 네이티브 응용 프로그램에 분산 트랜잭션이 없으면 분산 트랜잭션을 프로그래밍 방식으로 관리 해야 합니다. *즉시 일관성* 의 세계에서 *최종 일관성* 으로 이동 합니다.

그림 5-5에서는 문제를 보여 줍니다.

![Saga 패턴의 트랜잭션](./media/saga-transaction-operation.png)

**그림 5-5**. 마이크로 서비스에서 트랜잭션 구현

위의 그림에서 5 개의 독립 마이크로 서비스는 주문을 만드는 분산 트랜잭션에 참여 합니다. 각 마이크로 서비스는 자체 데이터 저장소를 유지 관리 하 고 해당 저장소에 대 한 로컬 트랜잭션을 구현 합니다. 주문을 만들려면 *각* 개별 마이크로 서비스의 로컬 트랜잭션이 성공 해야 합니다. 그렇지 않으면 *모두* 작업을 중단 하 고 롤백해야 합니다. 기본 제공 트랜잭션 지원은 각 마이크로 서비스 내에서 사용할 수 있지만 데이터 일관성을 유지 하기 위해 5 개 서비스 전체에 걸쳐 분산 된 트랜잭션을 지원 하지 않습니다.

대신이 분산 트랜잭션을 *프로그래밍 방식으로* 구성 해야 합니다.

분산 트랜잭션 지원을 추가 하는 일반적인 패턴은 Saga 패턴입니다. 로컬 트랜잭션을 프로그래밍 방식으로 그룹화 하 고 각 트랜잭션을 순차적으로 호출 하 여 구현 합니다. 로컬 트랜잭션이 실패 하면 Saga는 작업을 중단 하 고 [보정 트랜잭션](/azure/architecture/patterns/compensating-transaction)집합을 호출 합니다. 보정 트랜잭션은 위의 로컬 트랜잭션에의 한 변경 내용을 취소 하 고 데이터 일관성을 복원 합니다. 그림 5-6에서는 Saga 패턴을 사용 하는 실패 한 트랜잭션을 보여 줍니다.

![Saga 패턴으로 롤백](./media/saga-rollback-operation.png)

**그림 5-6**. 트랜잭션 롤백

위의 그림에서 inventory 마이크로 서비스에서 *Inventory 업데이트* 작업이 실패 했습니다. Saga는 보상 트랜잭션 집합 (빨간색)을 호출 하 여 재고 수를 조정 하 고, 지불 및 주문을 취소 하 고, 각 마이크로 서비스에 대 한 데이터를 다시 일관 된 상태로 되돌립니다.

Saga 패턴은 일반적으로 일련의 관련 이벤트 또는 오케스트레이션 관련 된 명령 집합으로 조율 됩니다. 4 장에서는 오케스트레이션 saga 구현의 기초가 되는 서비스 집계 패턴에 대해 설명 했습니다. 또한 조율 saga 구현의 기초가 되는 Azure Service Bus 및 Azure Event Grid 항목과 함께 이벤트에 대해 설명 했습니다.

## <a name="high-volume-data"></a>대량 데이터

대규모 클라우드 네이티브 응용 프로그램은 종종 대용량 데이터 요구 사항을 지원 합니다. 이러한 시나리오에서는 기존 데이터 저장 기술을 통해 병목 현상이 발생할 수 있습니다. 대규모 시스템에 배포 하는 복잡 한 시스템의 경우 명령과 쿼리의 역할 분리 (CQRS) 및 이벤트 소싱을 모두 통해 응용 프로그램 성능을 향상 시킬 수 있습니다.  

### <a name="cqrs"></a>CQRS

[CQRS](/azure/architecture/patterns/cqrs)는 성능, 확장성 및 보안을 최대화 하는 데 도움이 될 수 있는 아키텍처 패턴입니다. 패턴은 데이터를 쓰는 작업에서 데이터를 읽는 작업을 구분 합니다.

일반적인 *시나리오의 경우 읽기 및* 쓰기 작업에 동일한 엔터티 모델 및 데이터 리포지토리 개체가 사용 됩니다.

그러나 대량 데이터 시나리오는 읽기 및 쓰기에 대 한 별도의 모델 및 데이터 테이블을 활용 하는 이점을 누릴 수 있습니다. 성능 향상을 위해 읽기 작업은 비용이 많이 드는 반복적인 테이블 조인과 테이블 잠금을 방지 하기 위해 매우 비 정규화 된 데이터 표현을 쿼리할 수 있습니다. *명령* 이라고 하는 *쓰기* 작업은 일관성을 보장 하는 완전히 정규화 된 데이터 표현과 비교 하 여 업데이트 됩니다. 그런 다음 두 표현을 동기화 하기 위한 메커니즘을 구현 해야 합니다. 일반적으로 쓰기 테이블을 수정할 때마다 수정 내용을 읽기 테이블로 복제 하는 이벤트를 게시 합니다.

그림 5-7에서는 CQRS 패턴의 구현을 보여 줍니다.

![명령과 쿼리의 역할 분리](./media/cqrs-implementation.png)

**그림 5-7**. CQRS 구현

위의 그림에서는 별도의 명령 및 쿼리 모델을 구현 합니다. 각 데이터 쓰기 작업은 쓰기 저장소에 저장 된 다음 읽기 저장소로 전파 됩니다. [최종 일관성](https://www.cloudcomputingpatterns.org/eventual_consistency/)원칙에 따라 데이터 전파 프로세스가 작동 하는 방식에 주의 해야 합니다. 읽기 모델은 결국 쓰기 모델과 동기화 되지만 프로세스가 지연 될 수 있습니다. 다음 섹션에서 최종 일관성에 대해 설명 합니다.

이러한 분리를 통해 읽기 및 쓰기가 독립적으로 확장 될 수 있습니다. 읽기 작업은 쿼리에 최적화 된 스키마를 사용 하지만 쓰기는 업데이트에 최적화 된 스키마를 사용 합니다. 읽기 쿼리는 비 정규화 된 데이터를 기반으로 하며, 복잡 한 비즈니스 논리를 쓰기 모델에 적용할 수 있습니다. 또한 읽기를 노출 하는 것 보다 쓰기 작업에 대 한 보안을 강화 하는 것이 좋습니다.

CQRS를 구현 하면 클라우드 네이티브 서비스에 대 한 응용 프로그램 성능을 향상 시킬 수 있습니다. 그러나이로 인해 디자인이 더 복잡해 집니다. 이 원칙을 활용 하는 클라우드 네이티브 응용 프로그램의 해당 섹션에 신중 하 게 적용 합니다. CQRS에 대 한 자세한 내용은 Microsoft book [.Net 마이크로 서비스: 컨테이너 화 된 .Net 응용 프로그램 아키텍처](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md)를 참조 하세요.

### <a name="event-sourcing"></a>이벤트 소싱

대량 데이터 시나리오를 최적화 하는 또 다른 방법으로는 [이벤트 소싱](/azure/architecture/patterns/event-sourcing)이 포함 됩니다.

일반적으로 시스템은 데이터 엔터티의 현재 상태를 저장 합니다. 예를 들어 사용자가 전화 번호를 변경 하는 경우 고객 레코드는 새 숫자로 업데이트 됩니다. 항상 데이터 엔터티의 현재 상태를 알 수 있지만 각 업데이트는 이전 상태를 덮어씁니다.

대부분의 경우이 모델은 제대로 작동 합니다. 그러나 대용량 시스템에서 트랜잭션 잠금 및 빈번한 업데이트 작업으로 인 한 오버 헤드는 데이터베이스 성능, 응답성 및 한계 확장성에 영향을 줄 수 있습니다.

이벤트 소싱은 데이터를 캡처하는 다른 방법을 사용 합니다. 데이터에 영향을 주는 각 작업은 이벤트 저장소에 유지 됩니다. 데이터 레코드의 상태를 업데이트 하는 대신, 회계사의 원장과 유사 하 게 이전 이벤트의 순차적 목록에 각 변경 내용을 추가 합니다. 이벤트 저장소는 데이터에 대 한 레코드의 시스템이 됩니다. 마이크로 서비스의 제한 된 컨텍스트 내에서 다양 한 구체화 된 뷰를 전파 하는 데 사용 됩니다. 그림 5.8에서는 패턴을 보여 줍니다.

![이벤트 소싱](./media/event-sourcing.png)

**그림 5-8**. 이벤트 소싱

위의 그림에서 사용자의 쇼핑 카트에 대 한 각 항목 (파란색)은 기본 이벤트 저장소에 추가 되는 방식을 확인 합니다. 인접 한 구체화 된 뷰에서 시스템은 각 쇼핑 카트에 연결 된 모든 이벤트를 재생 하 여 현재 상태를 프로젝션 합니다. 그런 다음이 뷰 또는 읽기 모델은 UI에 다시 노출 됩니다. 이벤트를 외부 시스템 및 응용 프로그램과 통합 하거나 쿼리할 수 있으며 엔터티의 현재 상태를 확인할 수도 있습니다. 이 방법을 사용 하면 기록을 유지 관리할 수 있습니다. 엔터티의 현재 상태 뿐만 아니라이 상태에 도달 하는 방법에 대해서도 잘 알고 있습니다.

기계적 말하는 이벤트 소싱은 쓰기 모델을 단순화 합니다. 업데이트 또는 삭제가 없습니다. 각 데이터 항목을 변경할 수 없는 이벤트로 추가 하면 관계형 데이터베이스와 관련 된 경합, 잠금 및 동시성 충돌을 최소화할 수 있습니다. 구체화 된 뷰 패턴을 사용 하 여 읽기 모델을 빌드하면 쓰기 모델에서 뷰를 분리 하 고 가장 적합 한 데이터 저장소를 선택 하 여 응용 프로그램 UI의 요구 사항을 최적화할 수 있습니다.

이 패턴에서는 이벤트 소싱을 직접 지 원하는 데이터 저장소를 고려 합니다. Azure Cosmos DB, MongoDB, Cassandra,, RavenDB,는 좋은 후보입니다.

모든 패턴 및 기술과 마찬가지로 전략적이 고 필요한 경우 구현 합니다. 이벤트 소싱은 향상 된 성능 및 확장성을 제공할 수 있지만 복잡성과 학습 곡선이 있습니다.

>[!div class="step-by-step"]
>[이전](service-mesh-communication-infrastructure.md)
>[다음](relational-vs-nosql-data.md)
