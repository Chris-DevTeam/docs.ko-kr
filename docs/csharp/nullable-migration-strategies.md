---
title: Nullable 참조 형식을 사용하기 위한 코드베이스 업데이트
description: Nullable 참조 형식을 사용하기 위해 코드베이스를 업그레이드하는 최고의 전략을 선택합니다.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: ab0970247c7e3f3c20d7fdb40ef035c4ba1d8b01
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2020
ms.locfileid: "97866825"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a>Nullable 참조 형식을 사용하기 위해 라이브러리를 업데이트하고 호출자에 nullable 규칙 전달

[Nullable 참조 형식](nullable-references.md)를 추가하면 모든 변수에 `null` 값이 허용되거나 필요한지를 선언할 수 있습니다. 또한 `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, `NotNullIfNotNull` 등의 여러 특성을 적용하여 인수와 반환 값의 null 상태를 완전히 설명할 수 있습니다. 따라서 코드를 작성할 때 뛰어난 환경을 제공합니다. Null을 허용하지 않는 변수를 `null`로 설정할 수 있으면 경고가 표시됩니다. Nullable 변수를 역참조하기 전에 null 검사하지 않은 경우 경고가 발생합니다. 라이브러리 업데이트는 시간이 걸릴 수 있지만 얻는 결과를 보면 가치가 있습니다. 컴파일러에 `null` 값이 허용되거나 금지되는 ‘경우’에 관해 더 많은 정보를 제공하면 API 사용자에게 더 유용한 정보가 제공됩니다. 친숙한 예제부터 살펴보겠습니다. 라이브러리에 리소스 문자열을 검색하는 다음 API가 있다고 가정합니다.

```csharp
bool TryGetMessage(string key, out string message)
```

앞의 예제는 .NET의 친숙한 `Try*` 패턴을 따릅니다. 이 API에 대한 두 개의 참조 인수인 `key` 및 `message` 매개 변수가 있습니다. 이 API에는 해당 인수의 nullness에 관련된 다음 규칙이 있습니다.

- 호출자는 `null`을 `key`의 인수로 전달하지 않아야 합니다.
- 호출자는 값이 `null`인 변수를 `message`의 인수로 전달할 수 있습니다.
- `TryGetMessage` 메서드가 `true`를 반환하면 `message` 값은 null이 아닙니다. 반환 값이 `false,`이면 `message`의 값과 해당 null 상태는 null입니다.

`key`에 대한 규칙은 변수 형식으로 완전히 표현될 수 있습니다. `key`는 null을 허용하지 않는 참조 형식이어야 합니다. `message` 매개 변수는 더 복잡합니다. `null`을 인수로 허용하지만, 성공 시 해당 `out` 인수가 null이 아님을 보장합니다. 이 시나리오의 경우 기대치를 설명하는 더 다양한 어휘가 필요합니다.

Nullable 참조를 위해 라이브러리를 업데이트하려면 일부 변수 및 형식 이름에 `?`를 포함하는 것 이상의 작업이 필요합니다. 앞의 예제에서는 API를 검토하고 각 입력 인수의 기대 사항을 고려해야 함을 보여 줍니다. 반환 값의 보장과 메서드 반환의 `out` 또는 `ref` 인수를 고려합니다. 그런 다음 해당 규칙을 컴파일러에 전달하면 컴파일러에서 호출자가 해당 규칙을 준수하지 않는 경우 경고를 제공합니다.

이 작업에는 시간이 걸립니다. 우선 라이브러리나 애플리케이션에서 nullable을 인식하도록 하면서 다른 요구 사항도 적절하게 충족하는 전략을 따르겠습니다. 진행 중인 개발을 균형 있게 조정하여 nullable 참조 형식을 사용하도록 설정하는 방법을 살펴봅니다. 제네릭 형식 정의의 문제를 알아봅니다. 개별 API의 사전 및 사후 조건을 설명하는 특성을 적용하는 방법을 알아봅니다.

## <a name="choose-a-strategy-for-nullable-reference-types"></a>nullable 참조 형식을 위한 전략 선택

우선 nullable 참조 형식을 기본적으로 설정하거나 해제할지를 선택합니다. 두 가지 전략이 있습니다.

- 전체 프로젝트에서는 nullable 참조 형식을 사용하도록 설정하고 준비되지 않은 코드에서는 사용하지 않도록 설정합니다.
- Nullable 참조 형식에 대한 주석이 추가된 코드에만 nullable 참조 형식을 사용하도록 설정합니다.

첫 번째 전략은 nullable 참조 형식을 위해 라이브러리를 업데이트할 때 라이브러리에 다른 기능을 추가하는 경우에 가장 효과적입니다. 새로 개발하는 코드는 모두 nullable을 인식합니다. 기존 코드를 업데이트할 때는 해당 클래스에서 nullable 참조 형식을 사용하도록 설정합니다.

이 첫 번째 전략을 따르면 다음 단계를 수행합니다.

1. *.csproj* 파일에 `<Nullable>enable</Nullable>` 요소를 추가하여 전체 프로젝트에서 nullable 참조 형식을 사용하도록 설정합니다.
1. 프로젝트의 모든 소스 파일에 `#nullable disable` pragma를 추가합니다.
1. 각 파일을 작업할 때 pragma를 제거하고 경고가 있으면 해결합니다.

이 첫 번째 전략은 모든 파일에 pragma를 추가하는 사전 작업이 더 많이 필요합니다. 장점이라면 프로젝트에 추가되는 모든 새 코드 파일에서 nullable을 사용할 수 있습니다. 모든 새 작업은 nullable 인식이므로 기존 코드만 업데이트만 업데이트하면 됩니다.

두 번째 전략은 라이브러리가 안정적이며 개발에서 주로 nullable 참조 형식을 채택하는 데 중점을 두는 경우에 더 효과적입니다. API에 주석을 달 때 nullable 참조 형식을 설정합니다. 마쳤으면 전체 프로젝트에 대해 nullable 참조 형식을 사용하도록 설정합니다.

이 두 번째 전략을 따르면 다음 단계를 수행합니다.

1. Nullable을 인식하도록 할 파일에 `#nullable enable` pragma를 추가합니다.
1. 경고가 표시되면 해결합니다.
1. 전체 라이브러리가 nullable을 인식하도록 지정될 때까지 처음 두 단계를 계속합니다.
1. *.csproj* 파일에 `<Nullable>enable</Nullable>` 요소를 추가하여 전체 프로젝트에서 nullable 형식을 사용하도록 설정합니다.
1. 더 이상 필요하지 않으므로 `#nullable enable` pragma를 제거합니다.

이 두 번째 전략은 사전 작업이 덜 필요합니다. 단점이라면 새 파일을 만들 때 첫 번째 작업으로 pragma를 추가하고 여기에서 nullable을 인식하도록 설정해야 한다는 것입니다. 팀의 개발자가 위 작업을 잊는 경우 새 코드가 이제 작업의 백로그에 있게 되어 모든 코드에서 nullable을 인식하게 됩니다.

어떤 전략을 선택할지는 프로젝트에서 수행 중인 활성 개발이 얼마나 많은지에 따라 달라집니다. 프로젝트의 완성도와 안정도가 높아질수록 두 번째 전략이 더 효과적입니다. 개발 중인 기능이 많을수록 첫 번째 전략이 더 효과적입니다.

> [!IMPORTANT]
> 전역 null 허용 컨텍스트는 생성된 코드 파일에 적용되지 않습니다. 두 전략에서 null 허용 컨텍스트는 생성됨으로 표시된 모든 소스 파일에 대해 *disabled* 입니다. 즉, 생성된 파일의 API가 주석 처리되지 않습니다. 다음 네 가지 방법으로 파일은 생성됨으로 표시됩니다.
>
> 1. .editorconfig에서 해당 파일에 적용되는 섹션에 `generated_code = true`를 지정합니다.
> 1. 파일의 맨 위에 있는 주석에 `<auto-generated>` 또는 `<auto-generated/>`를 배치합니다. 해당 주석의 모든 줄에 넣을 수 있지만 주석 블록은 파일의 첫 번째 요소여야 합니다.
> 1. 파일 이름을 *TemporaryGeneratedFile_* 로 시작합니다.
> 1. 파일 이름을 *.designer.cs*, *.generated.cs*, *.g.cs* 또는 *.g.i.cs* 로 종료합니다.
>
> 생성기는 [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) 전처리기 지시문을 사용하여 옵트인할 수 있습니다.

## <a name="should-nullable-warnings-introduce-breaking-changes"></a>Nullable 경고에서 호환성이 손상되는 변경을 도입해야 하나요?

Nullable 참조 형식을 사용하도록 설정하기 전에 변수는 ‘nullable 인식 불가능’으로 간주됩니다. Nullable 참조 형식을 사용하도록 설정하면 해당 변수는 모두 ‘null을 허용하지 않습니다’. 컴파일러에서는 해당 변수가 null이 아닌 값으로 초기화되지 않은 경우 경고를 발생시킵니다.

또한 값이 초기화되지 않은 경우의 반환 값 때문에도 경고가 발생할 수 있습니다.

컴파일러 경고를 해결하는 첫 번째 단계는 매개 변수와 반환 형식에 `?` 주석을 사용하여 인수나 반환 값이 null일 수 있는 경우를 나타내는 것입니다. 참조 변수가 null이 될 수 없는 경우 원래 선언이 올바릅니다. 이 작업을 수행할 때 목표는 경고를 해결하는 것만이 아닙니다. 무엇보다 컴파일러에서 잠재적 null 값을 사용하는 사용자의 의도로 이해하게 만들어야 합니다. 경고를 검토할 때 라이브러리와 관련하여 다음으로 중요한 결정을 내리게 됩니다. 디자인 의도를 더 명확하게 전달하기 위해 API 시그니처를 수정하시겠습니까? 이전에 살펴본 `TryGetMessage` 메서드를 위한 더 나은 API 시그니처는 다음과 같을 수 있습니다.

```csharp
string? TryGetMessage(string key);
```

반환 값은 성공이나 실패를 나타내며 값을 찾은 경우 값을 전달합니다. 대부분의 경우 API 시그니처를 변경하면 null 값이 전달되는 방식이 개선될 수 있습니다.

그러나 퍼블릭 라이브러리나 사용자 기반이 대규모인 라이브러리의 경우 API 시그니처 변경을 도입하지 않는 것이 좋습니다. 해당 사례와 기타 일반적인 패턴의 경우 특성을 적용하여 인수나 반환 값이 `null`일 수 있는 경우를 더 명확히 정의할 수 있습니다. API의 표면 변경을 고려할지 여부와 관계없이 형식 주석만으로는 인수나 반환 값의 `null` 값을 설명하는 데 충분하지 않을 가능성이 큽니다. 해당 경우 특성을 적용하여 API를 더 명확하게 설명할 수 있습니다.

## <a name="attributes-extend-type-annotations"></a>특성을 통한 형식 주석 확장

변수의 null 상태에 대한 추가 정보를 표현하기 위해 여러 가지 특성이 추가되었습니다. C# 8에 null 허용 참조 형식을 도입하기 전에 작성한 모든 코드는 ‘null 인식 불가능’이었습니다.  즉, 모든 참조 형식 변수가 null일 수 있지만 null 검사가 필요하지 않습니다. 코드가 ‘null 허용 인식’이 되면 해당 규칙이 변경됩니다.  참조 형식은 `null` 값이 아니어야 하며 null 허용 참조 형식은 참조되기 전에 `null`에 대해 검사되어야 합니다.

API에 대한 규칙은 `TryGetValue` API 시나리오에서 살펴본 것처럼 더 복잡할 수 있습니다. 대부분의 API에는 변수가 `null`일 수 있거나 없는 경우에 대한 더 복잡한 규칙이 있습니다. 이러한 경우에는 특성을 사용하여 해당 규칙을 표현합니다. API의 의미 체계를 설명하는 특성은 [nullable 분석에 영향을 주는 특성](./language-reference/attributes/nullable-analysis.md)에 관한 문서에서 확인할 수 있습니다.

## <a name="generic-definitions-and-nullability"></a>제네릭 정의 및 null 허용 여부

제네릭 형식과 제네릭 메서드의 null 상태를 올바로 전달하려면 특별한 주의가 필요합니다. 각별한 주의가 필요한 이유는 nullable 값 형식과 nullable 참조 형식이 근본적으로 다르다는 점 때문입니다. `int?`는 `Nullable<int>`의 동의어이지만 `string?`는 컴파일러에서 추가한 특성을 갖는 `string`입니다. 결과적으로 컴파일러에서는 `T`가 `class`인지 `struct`인지를 모르면 `T?`의 올바른 코드를 생성할 수 없습니다.

그렇다고 nullable 형식(값 형식 또는 참조 형식 중 하나)을 폐쇄형 제네릭 형식의 형식 인수로 사용할 수 없다는 의미는 아닙니다. `List<string?>`와 `List<int?>`는 모두 `List<T>`의 유효한 인스턴스화입니다.

따라서 `T?`를 제네릭 클래스 또는 메서드 선언에서 제약 조건이 없이 사용할 수는 없습니다. 예를 들어 <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType>는 `T?`를 반환하도록 변경되지 않습니다. `struct` 또는 `class` 제약 조건을 추가하여 이 제한을 극복할 수 있습니다. 해당 제약 조건 중 하나가 있으면 컴파일러는 `T`와 `T?` 모두의 코드를 생성하는 방법을 알 수 있습니다.

제네릭 형식 인수에 사용되는 형식을 null을 허용하지 않는 형식으로 제한하는 것이 좋습니다. 이렇게 하려면 해당 형식 인수에 `notnull` 제약 조건을 추가합니다. 해당 제약 조건을 적용하면 형식 인수는 nullable 형식이 될 수 없습니다.

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a>런타임에 초기화되는 속성, 데이터 전송 개체, null 허용 여부

생성 후 설정됨을 의미하는 런타임에 초기화되는 속성의 null 허용 여부를 나타내려면 클래스에서 계속 원래 디자인 의도를 올바르게 표현하도록 특별히 고려해야 할 수 있습니다.

DTO(데이터 전송 개체)와 같이 런타임에 초기화되는 속성을 포함하는 형식은 데이터베이스 ORM(개체 관계형 매퍼), 역직렬 변환기, 다른 소스의 속성을 자동으로 채우는 일부 다른 구성 요소 등과 같은 외부 라이브러리에 의해 인스턴스화되는 경우가 많습니다.

Nullable 참조 형식을 사용하도록 설정하기 전에 학생을 나타내는 다음 DTO 클래스를 고려합니다.

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

이 경우 `Required` 특성으로 표시되는 디자인 의도에서는 이 시스템에서 `FirstName` 및 `LastName` 속성이 **필수** 이고 따라서 null이 아님을 나타냅니다.

`VehicleRegistration` 속성은 **필수가 아니므로** null일 수 있습니다.

Nullable 참조 형식을 사용하도록 설정할 때 원래 의도와 일치하도록 DTO의 속성 중 nullable일 수 있는 속성을 나타내려고 합니다.

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

이 DTO 경우 null일 수 있는 속성은 ``VehicleRegistration``뿐입니다.

그러나 컴파일러는 `FirstName` 및 `LastName` 모두에 대해 null을 허용하지 않는 속성이 초기화되지 않았음을 나타내는 `CS8618` 경고를 발생시킵니다.

원래 의도를 유지하면서 컴파일러 경고를 해결하는 세 가지 옵션을 사용할 수 있습니다. 해당 옵션은 모두 유효하지만, 코딩 스타일과 디자인 요구 사항에 가장 적합한 옵션을 선택해야 합니다.

### <a name="initialize-in-the-constructor"></a>생성자에서 초기화

초기화되지 않음 경고를 해결하는 데 적합한 방법은 생성자에서 속성을 초기화하는 것입니다.

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

이 접근 방식은 클래스를 인스턴스화하기 위해 사용하는 라이브러리가 생성자에서 매개 변수 전달을 지원하는 경우에만 적용됩니다.

라이브러리는 생성자에서 전부는 아니지만 ‘일부’ 속성의 전달을 지원할 수 있습니다. 예를 들어 EF Core에서는 일반 열 속성은 [생성자 바인딩](/ef/core/modeling/constructors)을 지원하지만 탐색 속성의 경우 지원하지 않습니다.

클래스를 인스턴스화하는 라이브러리 관련 설명서를 확인하여 생성자 바인딩을 지원하는 범위를 파악하세요.

### <a name="property-with-nullable-backing-field"></a>Nullable 지원 필드가 있는 속성

생성자 바인딩이 적합하지 않은 경우 이 문제를 해결하는 한 가지 방법으로 nullable 지원 필드가 있는 null을 허용하지 않는 속성을 사용할 수 있습니다.

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

해당 시나리오에서는 `FirstName` 속성을 초기화되기 전에 액세스하는 경우 API 계약이 잘못 사용되었으므로 코드에서 `InvalidOperationException`을 throw합니다.

지원 필드를 사용할 경우 일부 라이브러리에 특별히 고려할 사항이 있을 수 있습니다. 예를 들어 EF Core에서는 [지원 필드](/ef/core/modeling/backing-field) 올바로 사용하도록 구성해야 할 수 있습니다.

### <a name="initialize-the-property-to-null"></a>속성을 null로 초기화

Nullable 지원 필드 사용의 간단한 대안으로 또는 클래스를 인스턴스화하는 라이브러리가 해당 접근 방식과 호환되지 않는 경우 null 허용 연산자(`!`)를 통해 속성을 직접 `null`로 초기화할 수 있습니다.

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

프로그래밍 버그의 결과인 경우를 제외하고는 속성이 올바로 초기화되기 전에 속성에 액세스하여 런타임에 실제 null 값을 확인하지는 못합니다.

## <a name="see-also"></a>참조

- [기존 코드베이스를 nullable 참조로 마이그레이션](tutorials/upgrade-to-nullable-references.md)
- [EF Core에서 nullable 참조 형식 사용](/ef/core/miscellaneous/nullable-reference-types)
